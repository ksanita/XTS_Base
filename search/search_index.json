{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CodeReference/Diagnostics.html","title":"Basic Diagnostics","text":"<p>Project Diagnostics in this documentation focuses on troubleshooting during active project development, and does not provide functionality for Alarm Handling on a production system. Those functionalities must be added to this project on an application-specific basis.</p> <p>Several tools are made available in this project file to make development as quick and easy as possible, such as:</p> <ul> <li>Object status information</li> <li>Function block error codes</li> <li>Mover activity Event Log</li> <li>User Log Events</li> </ul> <p> </p> <p>As a starting point, always be sure to investigate the object status outputs in the variable viewer inside TwinCAT. Here we can immediately see a Mover which is:</p> <ul> <li>Currently destined for Station #0</li> <li>Most recently commanded via Position Trigger #2</li> <li>Has no active errors</li> </ul> <p>For more advanced troubleshooting steps, see the additional categories to the left.</p> <p></p>"},{"location":"CodeReference/ErrorMovers.html","title":"ErrorMovers","text":""},{"location":"CodeReference/ErrorMovers.html#invalid-references","title":"Invalid References","text":"<p>Objectives that return References to MoverLists or Movers have the potential to return invalid references. For example, a Station with no mover present can't possibly return a CurrentMover, because by definition no CurrentMover exists! To prevent this, it is important to ensure that all CurrentMover and CurrentMoverList output properties are only evaluated when a MoverInPosition, MoverPassedPosition, MoverInVelocity, etc. flag is true for the relevant Objective.</p> <pre><code>// There is no CurrentMover at the Station, so this code will not operate correctly!!\nIF Station[1].MoverInPosition = FALSE THEN\nStation[1].CurrentMover.MoveToPosition( 200 );\nEND_IF\n</code></pre> <p>Typically, calling methods on these invalid references would result in a Pagefault and halt the XAR. However this outcome can be frustrating and slows development. Instead, an imposter ErrorMover object is returned in these circumstances as a quality-of-life improvement. ErrorMovers replace all the method functionality of standard Movers and will instead generate Errors in TwinCAT. For example:</p> <p></p>"},{"location":"CodeReference/ErrorMovers.html#axis-linking","title":"Axis Linking","text":"<p>If ErrorMovers appear in the list of potentially linkable objects when connecting NC Axes to PLC axes, ensure that these objects are not selected.</p> <p>By default, ErrorMovers are removed from the PLC Process Image to prevent them appearing in this list.</p> <p></p>"},{"location":"CodeReference/EventLogger.html","title":"Event Logger","text":"<p>When the occasional programmed instruction leads to unexpected Mover behavior, it can be useful to look back at a logged history of Mover Events.</p> <p>In this project, every command issued to any Mover on the track is submitted as a log entry which can be viewed in TwinCAT:</p> <p></p>"},{"location":"CodeReference/EventLogger.html#user-events","title":"User Events","text":"<p>To make filtering through these events even easier, customer User Events can also be submitted to the Log.</p> <p>See Mover.LogUserEvent for more information.</p>"},{"location":"CodeReference/Mover.html","title":"Mover Object","text":"<p>The Mover function block is the heart of the solution. It contains essential functionality, including:</p> <ul> <li>Basic administrative commands like enabling &amp; resetting</li> <li>Easily commanding movements to absolute positions or stations</li> <li>Reading out current move status information like position, velocity, etc.</li> <li>Updating motion parameters during operation</li> </ul>"},{"location":"CodeReference/Mover.html#setup-execution","title":"Setup &amp; Execution","text":"<p>It is recommended, but not required, to declare Movers as an array. <pre><code>// Instance declaration\nMover           : ARRAY [0..GVL.NUM_MOVERS-1] OF Mover;\n\nParameterSet    : MoverParameters_typ;\n</code></pre></p> <p>Movers contain a Cyclic() method that must be called every cycle. This cyclic method must also be given a Collision Avoidance Group reference as an argument.</p> <pre><code>// Call this method cyclically\nFOR i := 0 TO GVL.NUM_MOVERS-1] DO\nMover[i].Cyclic( GroupRef );\nEND_FOR\n</code></pre>"},{"location":"CodeReference/Mover.html#methods","title":"Methods","text":""},{"location":"CodeReference/Mover.html#enable","title":"Enable","text":"<p>Enable()</p> <p>Carries out steps to prepare the Mover for motion commands.</p> <ol> <li>An internal MC_Reset function block is called to reset any errors that may exist on the Axis object.</li> <li>The mover will read M1 Detection Settings configured in the XtsProcessingUnit. If M1 Detection is configured, the Mover will activate this process to find Mover 1. If this is not configured, this step is skipped.</li> <li>An internal MC_Power function block is called to energize the axis object.</li> <li>The mover will automatically add itself to a Collision Avoidance group, and if necessary will also automatically enable this group.</li> <li>The mover will set its Ready output True.</li> </ol> <pre><code>Mover[1].Enable();\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#disable","title":"Disable","text":"<p>Disable()</p> <p>Disables the mover. Holding Torque will be lost. Method will automatically remove the mover from its Collision Avoidance group.</p> <pre><code>Mover[1].Disable();\n</code></pre>"},{"location":"CodeReference/Mover.html#groupstop","title":"GroupStop","text":"<p>GroupStop()</p> <p>Immediately stops all enabled movers on the system with the deceleration parameters of the mover on which the method was called.</p> <p>Since the method acts upon the collision avoidance group, all enabled movers on the system are immediately stopped and any active movements are cancelled. New motion commands to each mover are ignored until the Stop has completed.</p> <pre><code>IF xStopAllMovers THEN\nMover[0].GroupStop();\nxStopAllMovers      := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#halt","title":"Halt","text":"<p>Halt()</p> <p>Immediately stops the commanded mover with the deceleration parameters stored in the Mover object</p> <p>Halt does not alter the mover's internal axis state, so new movements can be executed at any point to send the mover onwards.</p> <pre><code>IF xStopSingleMover THEN\nMover[0].Halt();\nxStopSingleMover    := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#movetoposition","title":"MoveToPosition","text":"<p>MoveToPosition( Destination : LREAL )</p> <p>Executes an Absolute Move (with Collision Avoidance) to the target location.</p> <pre><code>IF xMoveCommand THEN\nMover[1].MoveToPosition( 1200 );\nxMoveCommand    := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#movetostation","title":"MoveToStation","text":"<p>MoveToStation( Destination : Station )</p> <p>Executes an Absolute Move (with Collision Avoidance) to the location of the target Station, and implicitly calls that Station's RegisterMover method.</p> <pre><code>IF xMoveToHome THEN\nMover[1].MoveToStation( Station[1] );\nxMoveToHome     := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#movevelocity","title":"MoveVelocity","text":"<p>MoveVelocity( DesiredVelocity : LREAL )</p> <p>Executes a Velocity movement (with Collision Avoidance) at the specified Velocity. This command also implicitly updates the Mover's internal Velocity Motion Parameter.</p> <pre><code>IF xMoveVelocity THEN\nMover[1].MoveVelocity( 2000 );\nxMoveVelocity   := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#synctoaxis","title":"SyncToAxis","text":"<p>SyncToAxis( MasterAxis : AXIS_REFERENCE, MasterSyncPos : LREAL, SlaveSyncPos : LREAL, SyncStrategy : MC_SYNC_STRATEGY )</p> <p>Pairs the current mover with an external axis (real or virtual) with specified Master &amp; Slave Sync Positions. The current mover will synchronize according to the parameter SyncStrategy and a 1:1 gear ratio. The synchronization can be ended by executing a call on the slave for any other motion command, e.g. MoveToPosition.</p> <p>MasterAxis is a reference to the NC axis object that the mover should synchronize with, real or virtual.</p> <p>MasterSyncPos is the position of the Master at which point the mover will be InSync and will have the correct gear ratio (1:1).</p> <p>SlaveSyncPos is the position of the mover at which point it is InSync</p> <p>SyncStrategy defines the type of calculation used to blend the movements and establish the synchronization. Simply put, the mover should synchronize immediately &amp; aggressively, as late as possible and aggressively, or as gently as possible.</p> <p>For more information on these inputs, see InfoSys documentation for the underlying MC_GearInPosCA Function Block</p> <p>See also: Mover.IsSyncedToAxis</p> <pre><code>IF xCmdSyncToAxis THEN\nxCmdSyncToAxis  := FALSE;\nMasterSyncPos   := ConveyorAxis.NcToPlc.ActPos + 400;\nMover[0].SyncToAxis( ConveyorAxis, MasterSyncPos, 1500, mcSyncStrategyEarly );\nEND_IF;\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#synctomover","title":"SyncToMover","text":"<p>SyncToMover( MasterMover : Mover, Gap : LREAL )</p> <p>Pairs the current mover with a desired mover at a specified gap distance. The current mover will immediately move (with CA) to a specified distance from the Master Mover and then mimic all motion from the master. The synchronization can be ended by executing a call on the slave for any other motion command, e.g. MoveToPosition.</p> <p>Gap specifies a center-to-center following distance between master and slave movers. This gap cannot be achieved if it is below the minimum collision avoidance distance established in the CA group. Positive Gap values will result in a following position behind the master and negative values will result in a slave that precedes the master.</p> <p>Additional calls to this method can be used to update the gap between paired movers.</p> <p>See also: Mover.IsSyncedToMover and Mover.MasterMover</p> <pre><code>IF xCmdSyncToLeader THEN\nMover[0].SyncToMover( Mover[1], 100 );  // move 100mm away from Mover 1\n\nIF Mover[0].IsSyncedToMover THEN\nMover[1].MoveToPosition( 2000 );    // Master moves to 2000 and Mover 0 will follow\nEND_IF;\nEND_IF;\n</code></pre> <pre><code>IF xBuildTrain THEN\nMover[3].SyncToMover( Mover[4], 100 );\nMover[2].SyncToMover( Mover[4], 200 );\nMover[1].SyncToMover( Mover[4], 300 );\nMover[0].SyncToMover( Mover[4], 400 );\n\nIF Mover[0].IsSyncedToMover THEN\n// Commands Mover 4 to move ahead at 300 mm/s\nMover[0].MasterMover.MoveVelocity( 300 );\nEND_IF;\nEND_IF;     </code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#reissuecommand","title":"ReissueCommand","text":"<p>ReissueCommand()</p> <p>Executes the latest command that was issued to the mover, e.g. a MoveToPosition command. The move is executed with the current internal Motion Parameters of the Mover, so the dynamics of the mover may not exactly match what was initially commanded. However, in cases of MoveToPosition or MoveToStation, the destination will be the same.</p> <p>To determine what type of movement ReissueCommand() will repeat, see Mover properties CurrentMoveType, CurrentObjective, and CurrentDestinationPosition.</p> <pre><code>// Issue a primary command\nIF xInitialCommand THEN\nMover[1].SetVelocity( 500 );\nMover[1].MoveToPosition( 1000 );\nxInitialCommand     := FALSE;\n\n// Reissue the primary command, but with a new velocity parameter\nELSIF xUpdateCommand THEN\nMover[1].SetVelocity( 750 );\nMover[1].ReissueCommand();\nxUpdateCommand      := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#loguserevent","title":"LogUserEvent","text":"<p>LogUserEvent( Text1 : STRING, Text2 : STRING, Text3 : STRING )</p> <p>Submits custom log events to the Event Logger which can be viewed in TwinCAT</p> <pre><code>IF PositionTrigger[1].MoverPassedPosition THEN\nPositionTrigger[1].CurrentMover.LogUserEvent('Mover Passed PT#1','','');\nEND_IF;\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#setacceleration","title":"SetAcceleration","text":"<p>SetAcceleration( DesiredAccel : LREAL )</p> <p>Updates the Mover's internal Motion Parameter for Acceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xCommandHighAccel THEN\nMover[1].SetAcceleration( 2e4 );    // mm/s2\nxCommandHighAccel       := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#setdeceleration","title":"SetDeceleration","text":"<p>SetDeceleration( DesiredDecel : LREAL )</p> <p>Updates the Mover's internal Motion Parameter for Deceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xCommandLowDecel THEN\nMover[1].SetDeceleration( 1e3 );    // mm/s2\nxCommandLowDecel    := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#setdirection","title":"SetDirection","text":"<p>SetDirection( Direction : Tc3_Mc3Definitions.MC_Direction );</p> <p>Updates the Mover's internal Motion Parameter for Direction and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <p>This method should only be used with care, and an understanding that a mover enroute will immediately reverse course and execute a motion command in the opposite direction when this method is called.</p> <pre><code>// For supported directions, see Infosys\n\nIF xReverseDirection THEN\nMover[1].SetDirection( mcDirectionPositive );\nxReverseDirection   := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#setjerk","title":"SetJerk","text":"<p>SetJerk( Jerk : LREAL )</p> <p>Updates the Mover's internal Motion Parameter for Jerk [mm/s3] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xUpdateJerk THEN\nMover[1].UpdateJerk( 1e5 );\nxUpdateJerk     := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Mover.html#setvelocity","title":"SetVelocity","text":"<p>SetVelocity( DesiredVelocity : LREAL )</p> <p>Updates the Mover's internal Motion Parameter for Velocity [mm/s] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xCommandSlowMode THEN\nMover[1].SetVelocity( 500 );    // mm/s\nxCommandSlowMode    := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Mover.html#properties","title":"Properties","text":""},{"location":"CodeReference/Mover.html#currentmovetype","title":".CurrentMoveType","text":"<p>MoverCommandType_enum</p> <pre><code>MOVETYPE_NONE           // this mover was just enabled and has no movement history\nMOVETYPE_POSITION       // this mover was most recently issued a MoveToPosition command\nMOVETYPE_STATION        // this mover was most recently issued a MoveToStation command\nMOVETYPE_VELOCITY       // this mover was most recently issued a MoveVelocity command\n</code></pre> <p>Provides the current (last executed) type of movement command issued to the Mover</p> <p> </p>"},{"location":"CodeReference/Mover.html#currentdestinationposition","title":".CurrentDestinationPosition","text":"<p>LREAL</p> <p>Provides the current destination position for the last movement command issued to the Mover. For Station commands, this will be the TrackPosition of the Station. For Velocity commands with no real destination position, the value is set to +/-1E300.</p> <p> </p>"},{"location":"CodeReference/Mover.html#motionparameters","title":".MotionParameters","text":"<p>MotionParameters_typ</p> <p>Defines a structure containing the dynamics settings for the Mover. Any new motion commands issued will utilize these values.</p> <p>Note: despite listing this value as a Property here in the documentation, MotionParameters are actually defined as a regular Input to the Mover object. This allows component access to the members of the STRUCT, which is not possible for Properties.</p> <p> </p>"},{"location":"CodeReference/Mover.html#currentobjective","title":".CurrentObjective","text":"<p>STRING</p> <p>Provides the current Objective destination for the Mover. Right now this is only valid when the Mover is destined for a Station objective, and provides a string name for that station.</p> <p> </p>"},{"location":"CodeReference/Mover.html#issyncedtomover","title":".IsSyncedToMover","text":"<p>BOOL</p> <p>Returns true if the mover is slaved to another mover and has successfully reached the following position specified by the Gap.</p> <p> </p>"},{"location":"CodeReference/Mover.html#issyncedtoaxis","title":".IsSyncedToAxis","text":"<p>BOOL</p> <p>Returns true if the mover is slaved to an external axis and has successfully reached the following position specified by the Master &amp; Slave Sync Positions</p> <p> </p>"},{"location":"CodeReference/Mover.html#mastermover","title":".MasterMover","text":"<p>REFERENCE To Mover</p> <p>Reference variable that refers to the Mover this Mover is currently slaved to</p> <p>When this mover is not slaved to another mover, .MasterMover is an invalid reference. There is therefore an ErrorMover object which will return information on what action was requested by the object while .MasterMover was invalid. This will show up in TwinCAT's Event Logs. See Diagnostics / ErrorMovers for more information.  </p> <p>It is recommended that all evaluations are nested inside IF checks for .IsSyncedToMover OR by calling __ISVALIDREF</p> <p> </p>"},{"location":"CodeReference/Mover.html#payload","title":".Payload","text":"<p>!!! Under Construction !!! At the moment, this property is a placeholder for application specific information regarding the current status of products onboard the mover, and can be modified as needed for your application.</p> <p> </p>"},{"location":"CodeReference/Mover.html#extra-examples","title":"Extra Examples","text":"<p>Below are simple examples of different operations utilizing the Mover object:</p> <pre><code>// Mover: ARRAY [0..GVL.NUM_MOVERS] OF Mover\nMover[1].SetVelocity( 2500 );\nMover[1].MoveToPosition( 1200 );\n</code></pre>"},{"location":"CodeReference/MoverList.html","title":"Mover List Object","text":"<p>The Mover List object provides a way to group Movers together and issue commands to every Mover in the list. Alternatively, commands can be sent to individual movers within the list based on their geographic proximity to a track position</p> <p> </p>"},{"location":"CodeReference/MoverList.html#setup-execution","title":"Setup &amp; Execution","text":"<pre><code>// Declaration\nMoverListA      : MoverList;\n</code></pre> <pre><code>// Usage\nMoverListA.RegisterMover( Mover[1] );\nMoverListA.RegisterMover( Mover[2] );\nMoverListA.RegisterMover( Mover[3] );\n\nMoverListA.SetAllVelocity( 1000 );\nMoverListA.MoveAllToStation( Station[4] );\n\nMoverListA.UnregisterAll();\n</code></pre>"},{"location":"CodeReference/MoverList.html#methods","title":"Methods","text":""},{"location":"CodeReference/MoverList.html#contains","title":"Contains","text":"<p>Contains( Mover: Mover )</p> <p>Returns TRUE if the MoverList already contains the input Mover</p> <pre><code>IF MoverListA.Contains( Mover[4] ) THEN\n// Yes, Mover 4 must exist in MoverListA\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#getmoverbylocation","title":"GetMoverByLocation","text":"<p>GetMoverByLocation( Index : USINT, Position : LREAL, Direction : Tc2_MC2.MC_Direction ) : REFERENCE TO Mover</p> <p>Returns a reference to a singular mover from the Mover List, based on it's geographic location relative to a fixed track position.</p> <p>Index specifies the number of movers that should lie between the selection and the Position input. Therefore Index = 0 would be the closest mover to the input position (in a given direction), Index = 1 would be the second closest, Index = 2 would be the third closest, etc.</p> <p>Position specifies the target around which mover proximity should be considered.</p> <p>Direction specifies the direction around the track from which the movers are indexed. Therefore MC_Positive_Direction will begin returning movers with the most positive absolute position values that are still less than the position input.</p> <pre><code>// Select a mover in the MoverList\n// Which is the first closest mover to position 900\n// And which has a position less than 900\n// Then sends it to a station\nMoverListA.GetMoverByLocation( 0, 900, MC_Positive_Direction ).MoveToStation( Station[3] );\n\n// Select a mover in the MoverList\n// Which is the third closest mover to position 2000\n// And which has a position greater than 3000\n// Then sets its acceleration\nMoverListA.GetMoverByLocation( 2, 3000, MC_Negative_Direction ).SetAcceleration( 1E4 );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#movealltoposition","title":"MoveAllToPosition","text":"<p>MoveAllToPosition( DestinationPosition : LREAL )</p> <p>Issues individual MoveToPosition commands to every mover registered with the list.</p> <pre><code>MoverListA.MoveAllToPosition( 1200 );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#movealltostation","title":"MoveAllToStation","text":"<p>MoveAllToStation( DestinationStation: Station )</p> <p>Issues individual MoveToStation commands to every mover registered with the list.</p> <pre><code>MoverListA.MoveAllToStation( Station[3] );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#moveallvelocity","title":"MoveAllVelocity","text":"<p>MoveAllVelocity( DesiredVelocity : LREAL )</p> <p>Issues individual MoveVelocity commands to every mover registered with the list.</p> <pre><code>MoverListA.MoveAllVelocity( 300 );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#setallacceleration","title":"SetAllAcceleration","text":"<p>SetAllAcceleration( DesiredAcceleration : LREAL )</p> <p>Sets the acceleration motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllAcceleration( 1E3 );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#setalldeceleration","title":"SetAllDeceleration","text":"<p>SetAllDeceleration( DesiredDeceleration : LREAL )</p> <p>Sets the deceleration motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllDeceleration( 15000 );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#setalldirection","title":"SetAllDirection","text":"<p>SetAllDirection( Direction : Tc3_Mc3Definitions.MC_DIRECTION )</p> <p>Sets the direction motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllDirection( mcDirectionPositive );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#setalljerk","title":"SetAllJerk","text":"<p>SetAllJerk( DesiredJerk : LREAL )</p> <p>Sets the jerk motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllJerk( 1e5 );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#setallvelocity","title":"SetAllVelocity","text":"<p>SetAllVelocity( DesiredVelocity : LREAL )</p> <p>Sets the velocity motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllVelocity( 2000 );\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#stopall","title":"StopAll","text":"<p>StopAll()</p> <p>Stops all movers in the list by calling their individual Stop methods</p> <pre><code>MoverListA.StopAll();\n</code></pre> <p> </p>"},{"location":"CodeReference/MoverList.html#unregisterall","title":"UnregisterAll","text":"<p>UnregisterAll()</p> <p>Unregisters every mover from the list immediately</p> <pre><code>MoverListA.UnregisterAll();\n</code></pre>"},{"location":"CodeReference/Objectives.html","title":"Project Overview","text":""},{"location":"CodeReference/Objectives.html#broad-concept","title":"Broad Concept","text":"<p>The core concept driving the project structure is that it is useful to address movers contextually as opposed to directly.</p> <p>To illustrate, consider a scenario of recovering from an E-Stop where a robot is positioned directly in the path of the movers. In this instance, a first step might be to command any movers downstream of the robot to move further downstream, and movers upstream of the robot should be commanded further upstream in order to create some space for the arm to reset.</p> <p>As a programmer, one wouldn't seek to specifically command Mover #4 and Mover #5 to carry out those instructions because during the next occurence it may be an entirely different pair of movers in this situation. Instead, the commands are issued to whichever movers are closest to the robot right now.</p> <p>In this sense, we take a list of all movers on the track system, and apply filters to help select only the movers we care to command. These filters are applied via a family of objects called Objectives.</p>"},{"location":"CodeReference/Objectives.html#objectives","title":"Objectives","text":"<p>Objective is an umbrella term used by the project, that includes the following objects:</p> <ul> <li>Stations</li> <li>Zones</li> <li>SpeedTriggers</li> <li>PositionTriggers</li> <li>MoverLists</li> </ul> <p>Each Objective defines a set criteria that a Mover can either fulfill or not at any given point. As an example, a Mover fulfills the criteria of a Station when it is parked at the Station's configured track position.</p> <p>When a Mover satisfies the requirements of the Objective, the Objective provides a Reference to the Mover through which new Mover commands can be issued.</p>"},{"location":"CodeReference/Objectives.html#currentmover","title":".CurrentMover","text":"<p>CurrentMover is the Reference output through which Movers can be addressed contextually via an Objective. Let's look at a simple example:</p> <pre><code>Station[3].CurrentMover;    // is equivalent to...\nMover[4];                   // as long as Mover #4 is parked at Station#3\n</code></pre> <p>And as a Reference, this CurrentMover output accepts any Method call instructions that a base Mover object could. E.g.:</p> <pre><code>Station[3].CurrentMover.SetVelocity( 2000 );    // is equivalent to...\nMover[4].SetVelocity( 2000 );   // so long as the the Mover is parked as above\n</code></pre> <p> </p>"},{"location":"CodeReference/Objectives.html#common-methods","title":"Common Methods","text":"<p>The objects listed above all share some common methods, which are implemented in the parent Objective base class.</p> <p> </p>"},{"location":"CodeReference/Objectives.html#registermover","title":"RegisterMover","text":"<p>RegisterMover( NewMover : Mover )</p> <p>Adds a Mover to the list of Tracked Movers that the objective is currently monitoring. If the input Mover has already been added to the Tracked Movers list, the method call is ignored.</p> <pre><code>Mover[1].MoveToPosition( Station[1].TrackPosition );\nStation[1].RegisterMover( Mover[1] );\n</code></pre> <p>The code above is similar in functionality to:</p> <pre><code>Mover[1].MoveToStation( Station[1] );\n</code></pre> <p>Stations include some unique features regarding mover registration. See Station Object for more details.</p> <p> </p>"},{"location":"CodeReference/Objectives.html#unregistermover","title":"UnregisterMover","text":"<p>RegisterMover( ExistingMover : Mover )</p> <p>Removes a Mover from the list of Tracked Movers that the objective is currently monitoring. If the input Mover is not already tracked by the objective, the method call is ignored.</p> <pre><code>Mover[1].MoveToStation( Station[1] );\nStation[1].UnregisterMover( Mover[1] );\n</code></pre> <p>Because the Mover would not be registered with the Station when it arrives, the Station would not report that the Mover is InPosition. The code above is functionally identical to:</p> <pre><code>Mover[1].MoveToPosition( Station[1].TrackPosition );\n</code></pre> <p> </p>"},{"location":"CodeReference/Objectives.html#unregistercurrent","title":"UnregisterCurrent","text":"<p>UnregisterCurrent( )</p> <p>Automatically unregisters whatever mover is listed as CurrentMover for the Objective</p> <p>Here the MoverInPosition status output changes. The mover is still physically located at the Station position, but since it is no longer registered, it cannot report MoverInPosition.</p> <pre><code>bCheck  := Station[1].MoverInPosition;  // returns TRUE\nStation[1].UnregisterCurrent();\nbCheck  := Station[1].MoverInPosition;  // returns FALSE\n</code></pre> <pre><code>IF PositionTrigger[1].MoverPassedPosition THEN\nPositionTrigger[1].CurrentMover.SetVelocity( 200 );\nPositionTrigger[1].UnregisterCurrent();\nEND_IF\n</code></pre> <p>---6  </p>"},{"location":"CodeReference/Objectives.html#unregisterall","title":"UnregisterAll","text":"<p>UnregisterAll()</p> <p>Automatically unregisters every mover from the Tracked Movers list</p> <pre><code>IF xClearTrigger THEN\nPositionTrigger[2].UnregisterAll();\nxClearTrigger   := FALSE;\nEND_IF\n</code></pre> <p> </p>"},{"location":"CodeReference/Objectives.html#method-chaining","title":"Method Chaining","text":"<p>Most methods in the project return the current object itself, allowing for additional method calls on the same line of code. This approach is often referred to as a fluent interface. For example:</p> <pre><code>// All these method calls apply to Mover 0 in sequence\nMover[0].SetVelocity( 2000 ).SetAcceleration( 20000).MoveToPosition( 1000 );\n</code></pre> <p>In some cases, the order of the methods calls must be carefully considered. In the following example, the CurrentMover of Station#0 is commanded to move to Station#1. At this point, it is no longer considered the CurrentMover of Station#0. As a result, the SetVelocity method does not apply to the intended Mover object.</p> <pre><code>IF Station[0].MoverInPosition THEN\n// This line will return an ErrorMover and will not function as intended\nStation[0].CurrentMover.MoveToStation(Station[1]).SetVelocity(1000);\nEND_IF;\n</code></pre> <p>However, the following example will work as intended:</p> <pre><code>IF Station[0].MoverInPosition THEN\n// This line of code will function correctly\nStation[0].CurrentMover.SetVelocity(1000).MoveToStation(Station[1]);\nEND_IF;\n</code></pre>"},{"location":"CodeReference/PositionTrigger.html","title":"Position Trigger Object","text":"<p>Position Trigger objects monitor movers until they have crossed over a specified location on track, even if they do not stop there. Position Triggers will always point to the most recent registered mover which crossed over the Position Trigger's track position</p> <p> </p>"},{"location":"CodeReference/PositionTrigger.html#setup-execution","title":"Setup &amp; Execution","text":"<pre><code>// Declaration\nPositionTriggerA        : PositionTrigger;\n</code></pre> <pre><code>// Initialization\nPositionTriggerA.TrackPosition      := 2000;\nPositionTriggerA.TriggerDirection   := mcDirectionPositive;\n</code></pre>"},{"location":"CodeReference/PositionTrigger.html#methods","title":"Methods","text":""},{"location":"CodeReference/PositionTrigger.html#cyclic","title":"Cyclic","text":"<p>Cyclic()</p> <p>Position Triggers require a cyclic call in the Main Program because they need to constantly monitor the positions of registered movers.</p> <p> </p>"},{"location":"CodeReference/PositionTrigger.html#mutecurrent","title":"MuteCurrent","text":"<p>MuteCurrent()</p> <p>Clears a Mover reference from the CurrentMover property, and resets MoverPassedPosition to be false. This can be done without the need to unregister a mover from a position trigger</p> <p>Since Position Triggers uniquely latch their CurrentMover output, it is necessary to clear this value manually in order to prepare to process the next mover event.</p> <pre><code>IF PositionTrigger[0].MoverPassedPosition THEN\nPositionTrigger[0].CurrentMover.MoveVelocity( 200 );\nPositionTrigger[0].MuteCurrent();\nEND_IF\n</code></pre> <p>In this way, it is possible to reset the position trigger without having to completely unregister and re-register a mover from the trigger.</p> <p> </p>"},{"location":"CodeReference/PositionTrigger.html#properties","title":"Properties","text":""},{"location":"CodeReference/PositionTrigger.html#moverpassedposition","title":".MoverPassedPosition","text":"<p>Status boolean indicating that at least one mover has passed over the threshold position since being registered</p> <p>Position Triggers are unique in that the Current Mover output latches even though the mover may not still qualify under the trigger condition</p> <p> </p>"},{"location":"CodeReference/PositionTrigger.html#currentmover","title":".CurrentMover","text":"<p>Reference variable that refers to the most recent registered mover to cross over the track position since being registered</p> <ul> <li> <p>If no movers are tracked, or no tracked movers have yet satisfied the objective, then .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT event logs. See Diagnostics &gt; ErrorMovers for more information.</p> </li> <li> <p>For this reason, it is recommended that all evaluations are nested inside IF checks for .MoverPassedPosition.</p> </li> <li> <p>It is possible that multiple registered movers have crossed over a threshold position. Only the most recently valid mover handle is provided by .CurrentMover.</p> </li> </ul> <p> </p>"},{"location":"CodeReference/PositionTrigger.html#trackposition","title":".TrackPosition","text":"<p>Current placement of the Position Trigger threshold along the track</p> <p> </p>"},{"location":"CodeReference/PositionTrigger.html#extra-examples","title":"Extra Examples","text":"<pre><code>// Basic Position Trigger implementation\n\n// Begin monitoring Mover 1\nIF bInit THEN\nMover[1].MoveToPosition( 1000 );\nPositionTrigger.TrackPosition   := 800;\nPositionTrigger.RegisterMover( Mover[1] );\nbInit   := FALSE;\nEND_IF\n\n// When Mover 1 crosses position 800, slow it down to 100mm/s\nIF PositionTrigger.MoverPassedPosition THEN\nPositionTrigger.CurrentMover.SetVelocity( 100 );\n// MuteCurrent clears MoverPassedPosition and CurrentMover so that\n// Line 12 does not continually evaluate as true\nPositionTrigger.MuteCurrent();\nEND_IF\n</code></pre>"},{"location":"CodeReference/SpeedTrigger.html","title":"Speed Trigger Object","text":"<p>Speed Trigger objects monitor movers until they have exceeded a specified velocity.</p> <p> </p>"},{"location":"CodeReference/SpeedTrigger.html#setup-execution","title":"Setup &amp; Execution","text":"<pre><code>// Declaration\nSpeedTriggerA       : SpeedTrigger;\n</code></pre> <pre><code>// Initization\nSpeedTriggerA.ThresholdVelocity     := 800;\n</code></pre>"},{"location":"CodeReference/SpeedTrigger.html#properties","title":"Properties","text":""},{"location":"CodeReference/SpeedTrigger.html#moverinvelocity","title":".MoverInVelocity","text":"<p>Status boolean indicating that at least one mover is currently exceeding the threshold velocity</p> <p> </p>"},{"location":"CodeReference/SpeedTrigger.html#currentmover","title":".CurrentMover","text":"<p>Reference variable that refers to the earliest registered mover to exceed the threshold velocity since being registered</p> <ul> <li> <p>If no movers are tracked, or no tracked movers currently satisfy the objective, then .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT event logs. See Diagnostics&gt;ErrorMovers for more information.</p> </li> <li> <p>It is recommended that all evaluations are nested inside IF check for .MoverInVelocity.</p> </li> <li> <p>It is possible that multiple registered movers simultaneously exceed the threshold velocity. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with SpeedTrigger.UnregisterCurrent()</p> </li> </ul> <p> </p>"},{"location":"CodeReference/SpeedTrigger.html#thresholdvelocity","title":".ThresholdVelocity","text":"<p>Current velocity, above which a mover is considered 'In Velocity'</p> <p> </p>"},{"location":"CodeReference/SpeedTrigger.html#extra-examples","title":"Extra Examples","text":"<pre><code>// Basic Speed Trigger implementation\n\n// Begin monitoring Mover 1\nIF bInit THEN\nMover[1].MoveToPosition( 1000 );\nSpeedTrigger.ThresholdVelocity  := 600; // mm/s\nbInit   := FALSE;\nEND_IF\n\n// When Mover 1 accelerates past 600mm/s, slow it down to 100mm/s\nIF SpeedTrigger.MoverInVelocity THEN\nSpeedTrigger.CurrentMover.SetVelocity( 100 );\nSpeedTrigger.UnregisterCurrent();\nEND_IF\n</code></pre>"},{"location":"CodeReference/Station.html","title":"Station Object","text":"<p>The Station object provides a fixed location for a Mover to stop at until it is ready to be released. A Station is a type of Objective, and provides a handle to the Mover object that is currently docked with the Station, allowing further motion commands to be issued to the Mover.</p> <p> </p>"},{"location":"CodeReference/Station.html#setup-execution","title":"Setup &amp; Execution","text":"<pre><code>// Declaration\nStation     : ARRAY [0..GVL.NUM_STATIONS-1] OF Station;\n</code></pre> <pre><code>// Initialization\nStation[1].TrackPosition        := 250;\nStation[2].TrackPosition        := 500;\nStation[3].TrackPosition        := 750;\n</code></pre> <pre><code>// Call this method cyclically\nFOR i := 0 TO GVL.NUM_STATIONS - 1 DO\nStation[i].Cyclic();\nEND_FOR\n</code></pre>"},{"location":"CodeReference/Station.html#mover-registration","title":"Mover Registration","text":"<p>Unlike other types of Objectives, Stations manage mover registration automatically. Any mover that is commanded with a MoveToStation is also automatically registered with that station. As an example, this implementation would be redundant:</p> <pre><code>Mover[2].MoveToStation( Station[3] );\nStation[3].RegisterMover( Mover[2] );       // unnecessary\n</code></pre> <p>Stations also automatically unregister movers that have been redirected with another move command, even if that command's destination is the same as the Station.</p> <pre><code>Mover[2].MoveToStation( Station[3] );\nMover[2].MoveToPosition( Station[3].TrackPosition );\n</code></pre> <p>Here, the Station will not report MoverInPosition.</p> <p> </p>"},{"location":"CodeReference/Station.html#methods","title":"Methods","text":""},{"location":"CodeReference/Station.html#cyclic","title":"Cyclic","text":"<p>Cyclic()</p> <p>Stations require a cyclic call in the Main program. This allows the station to automatically unregister movers from its Tracked list who have been redirected and are no longer destined for this Station.</p> <pre><code>FOR i := 0 TO GVL.NUM_STATIONS - 1 DO\nStation[i].Cyclic()\nEND_FOR\n</code></pre> <p> </p>"},{"location":"CodeReference/Station.html#properties","title":"Properties","text":""},{"location":"CodeReference/Station.html#moverinposition","title":".MoverInPosition","text":"<p>Status boolean indicating that a mover is currently docked with the Station</p> <p> </p>"},{"location":"CodeReference/Station.html#currentmover","title":".CurrentMover","text":"<p>Reference variable that refers to the Mover that is docked with the Station</p> <p>When no mover is present in the Station, .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT Event Logs.</p> <p>It is recommended that all evaluations are nested inside IF checks for .MoverInPosition.</p> <p> </p>"},{"location":"CodeReference/Station.html#trackedmovercount","title":".TrackedMoverCount","text":"<p>Simply reports the number of Movers that are currently registered with the Station. Because Stations automatically deregister movers that are not currently destined for this Station, this value also represents the current number of incoming movers</p> <p> </p>"},{"location":"CodeReference/Station.html#trackposition","title":".TrackPosition","text":"<p>Current placement of the Station along the track</p> <p> </p>"},{"location":"CodeReference/Station.html#extra-examples","title":"Extra Examples","text":"<pre><code>// Basic Station implementation with a 1s dwell time\nIF Station[0].MoverInPosition THEN\nStationTimer( IN := TRUE, PT := T#1000MS ); // TON\n\nIF StationTimer.Q THEN\nStation[0].CurrentMover.MoveToStation( Station[1] );\nEND_IF\nELSE\nStationTimer( IN := FALSE );\nEND_IF\n</code></pre> <pre><code>// Immediately redirect all incoming shuttles to Station 1 instead of Station 0\nFOR i := 0 TO Station[0].TrackedMoverCount-1 DO\nStation[0].TrackedMovers[i]^.MoveToStation( Station[1] );\nEND_FOR\n</code></pre>"},{"location":"CodeReference/UtilityLibrary.html","title":"Utility Library","text":""},{"location":"CodeReference/UtilityLibrary.html#tc3_xts_utility","title":"Tc3_XTS_Utility","text":"<p>The XTS Utility library is installed as a component of TF5850 and provides advanced-level access to a huge amount of data and functionality in the XTS system. Nearly every value, parameter, or setting visible in the various windows of the XTS Configuration is accessible via this library.</p> <p>Things like module temperatures, coil currents, and segment BTNs can all be read from the track system using this library. Write-access is provided to some parameters, allowing additional functionality like: on-the-fly tuning changes, manually triggering mover detection, and more.</p>"},{"location":"CodeReference/UtilityLibrary.html#documentation","title":"Documentation","text":"<p>Specific library documentation for Tc3_XTS_Utility can be found on Infosys in the link below.</p> <p>Infosys Tc3 XTS Utility Documentation</p>"},{"location":"CodeReference/UtilityLibrary.html#base-project-use","title":"Base Project Use","text":""},{"location":"CodeReference/UtilityLibrary.html#code-objects","title":"Code Objects","text":"<p>An instance of the library's core object, FB_TcIoXtsEnvironment, is included in the Base Project for your use along with a simple commmented example in the MAIN (PRG). More code examples are provided in the Examples section below. Often, you can search through the interface inside TwinCAT using autocomplete to find the information you're looking for.</p>"},{"location":"CodeReference/UtilityLibrary.html#diagnostic-visu","title":"Diagnostic VISU","text":"<p>An organized Diagnostic PLC VISU is also provided by the library, and has been added to this project. It contains a preconfigured GUI to check diagnostics for the XTS driver, parts, modules, movers, and tracks.</p> <p>More information on this visualization tool is also available on the official Infosys page.</p>"},{"location":"CodeReference/UtilityLibrary.html#example-usage","title":"Example Usage","text":"<pre><code>// Get the number of Motor Modules configured on the system\nmyMotorCount    := fbXtsEnvironment.XpuTcIo(1).PartTcIo(1).GetModuleCount();\n</code></pre> <pre><code>// Get the total distance travelled for a specific mover\nmyMoverMileage  := fbXtsEnvironment.XpuTcIo(1).MoverTcIo(1).GetDistanceDrivenInKm();\n</code></pre> <pre><code>// Update mover tuning parameter (must be done with care)\nfbXtsEnvironment.XpuTcIo(1).MoverTcIo(1).SoftDrive.VelocityControl.SetKp(1.5);\n</code></pre>"},{"location":"CodeReference/Zone.html","title":"Zone Object","text":"<p>The Zone object provides a method for grabbing all Movers within a specified geographic area on the track. A Zone is defined by a Start Position and an End Position, and returns every mover between these points. Zones are especially useful for programming recovery scenarios.</p> <p> </p>"},{"location":"CodeReference/Zone.html#setup-execution","title":"Setup &amp; Execution","text":"<p><pre><code>// Declaration\nZoneLeftSide        : Zone;\nZoneRightSide       : Zone;\n</code></pre> <pre><code>// Initialization\nZoneLeftSide.StartPosition  := 0;\nZoneLeftSide.EndPosition    := 2000;\n\nZoneRightSide.StartPosition := 2000;\nZoneRightSide.EndPosition   := 4000;\n</code></pre></p> <p> </p>"},{"location":"CodeReference/Zone.html#methods","title":"Methods","text":""},{"location":"CodeReference/Zone.html#getmover","title":"GetMover","text":"<p>GetMover( Index : USINT, Direction : Tc2_MC2.MC_Direction) : REFERENCE TO Mover</p> <p>Provides a reference to the Mover that has n = Index movers between it and the end of the Zone specified by the Direction</p> <pre><code>// Selects the mover closest to the Zone's End Position\n// Then issues a motion command\nZoneLeftSide.GetMover( 0, MC_Positive_Direction ).MoveToPosition( 2000 );\n\n// Selects the fourth-closest mover to the Zone's Start Position\n// Then sets its velocity\nZoneRightSide.GetMover( 3, MC_Negative_Direction ).SetVelocity( 1200 );\n</code></pre> <p> </p>"},{"location":"CodeReference/Zone.html#properties","title":"Properties","text":""},{"location":"CodeReference/Zone.html#currentmoverlist","title":".CurrentMoverList","text":"<p>Provides a MoverList object reference, containing all Movers that are currently within the boundaries set by Start Position and End Position. As a MoverList, methods are provided to command all movers as a group. See MoverList objective for more information</p> <pre><code>// Command all movers from position 0 through 2000 to Station#1\nZoneLeftSide.CurrentMoverList.MoveAllToStation( Station[1] );\n\n// Command all movers from position 2000 through 4000 to Station#2\nZoneRightSide.CurrentMoverList.MoveAllToStation( Station[2] );\n\n// Command the singular mover which is closest to the end of the zone to Station#3\nZone.CurrentMoverList.GetMoverByLocation(0,Zone.EndPosition,MC_Positive_Direction).MoveToStation( Station[3] );\n</code></pre>"},{"location":"CodeReference/Zone.html#startposition","title":".StartPosition","text":"<p>Defines the lower bound for the track region considered by the Zone object.</p>"},{"location":"CodeReference/Zone.html#endposition","title":".EndPosition","text":"<p>Defines the upper bound for the track region considered by the Zone object.</p>"},{"location":"CodeReference/Zone.html#zonelength","title":".ZoneLength","text":"<p>Calculates the length of the defined zone, in millimeters.</p>"},{"location":"Examples/StationRouting.html","title":"Station Routing","text":"<p>This example demonstrates the most basic Station to Station routing. There are two stations which dwell for a period of time before sending movers to the next station in the sequence</p> <pre><code>MS_RUN:     // ----------------------------------- OPERATING\n\n\n// Station 0 Logic\nIF Station[0].MoverInPosition THEN\nStationTimer[0]( IN := TRUE, PT := T#1000MS );\n\nIF StationTimer[0].Q THEN\n\nStation[0].CurrentMover.SetVelocity( 500 );\nStation[0].CurrentMover.MoveToStation( Station[1] );\n\nEND_IF\nELSE\n// Reset the timer for the next mover\nStationTimer[0]( IN := FALSE );\nEND_IF\n\n\n\n\n// Station 1 Logic\nIF Station[1].MoverInPosition THEN\nStationTimer[1]( IN := TRUE, PT := T#2s );\n\nIF StationTimer[1].Q THEN\n\n// Same behavior as above, but utilizing method chaining\nStation[1].CurrentMover.SetVelocity( 90 ).MoveToStation( Station[0] );\n\nEND_IF\nELSE\n// Reset the timer for the next mover\nStationTimer[1]( IN := FALSE );\nEND_IF\n</code></pre>"},{"location":"GettingStarted/GettingStarted.html","title":"Getting Started","text":""},{"location":"GettingStarted/GettingStarted.html#project-requirements","title":"Project Requirements","text":"<p>For new projects, the latest versions of TwinCAT and XTS software should be utilized.</p> <p>All XTS projects will require:</p> <ul> <li>TF5850</li> <li>TF5410</li> </ul>"},{"location":"GettingStarted/GettingStarted.html#configuring-xts-hardware","title":"Configuring XTS Hardware","text":"<p>The base project includes a simulated configuration for a 4m oval track and 6 movers. In order to modify the program to fit a different track configuration, navigate to the XTS Tool Window.</p> <p></p> <p>Then launch the XTS Configurator and follow the prompts to configure your system.</p> <p>The configurator occasionally conflicts with existing settings in the project. To avoid this, it can help to delete the following prior to running the XTS Configurator:</p> <ul> <li>XtsProcessingUnit</li> <li>All Mover Axis Object</li> <li>Existing XTS_Task</li> <li>Any hardware in the IO section.</li> </ul> <p></p>"},{"location":"GettingStarted/GettingStarted.html#initialization-settings","title":"Initialization Settings","text":"<p>Once your hardware configuration is set, you will need to change a few variable parameters in the code to match the system.</p> <p>Inside MOTION &gt; Objects &gt; Collision Avoidance (CA Group), set the Rail Length parameter to match your hardware.</p> <p></p> <p>Next, open the GVL file within PLC and modify these constants to match your system.</p> <p></p> <p>Next, check that each of your Axis objects are properly linked to a corresponding Mover object.</p> <p>!!! Note The project contains ErrorMover objects which also appear as options when linking axes. Do not link axes to these variables.</p> <p></p> <p>Lastly, open the XtsProcessingUnit within SYSTEM and verify that every setting here is correct</p> <p></p>"},{"location":"GettingStarted/Introduction.html","title":"Introduction","text":"<p>This site serves as reference documentation for the XTS Base Project. This site is not intended as a complete training guide on the XTS system, and contains no information on the electrical or mechanical setup of the system.</p>"},{"location":"GettingStarted/Introduction.html#additional-resources","title":"Additional Resources","text":"<ul> <li>Project Github</li> <li>Beckhoff XTS Page</li> </ul>"},{"location":"GettingStarted/QuickTips.html","title":"Quick Tips","text":""},{"location":"GettingStarted/QuickTips.html#programming-quick-tips","title":"Programming Quick Tips","text":"<p>Here are a few quick tips to assist in developing with this project:</p> <ul> <li> <p>Methods are designed to be called once, not repeatedly.</p> </li> <li> <p>Collision avoidance should be the source of buffering, there should rarely be a reason for a buffer location to be user defined. </p> </li> <li> <p>Movers Contain an AxisRef, it can be useful to put 'Mover[i].AxisReference.ReadStatus();' in the code with the  Cyclic call for the same, the Status values of an AxisRef can be very useful. </p> </li> </ul> <pre><code>// Call this method cyclically\nFOR i := 0 TO GVL.NUM_MOVERS-1] DO\nMover[i].Cyclic( GroupRef );\nMover[i].AxisReference.ReadStatus();\nEND_FOR\n</code></pre> <ul> <li> <p>When using .CurrentMover properties (or similar), always wrap usage with a check for .MoverInPosition or similar, to verify that the pointers are valid. See ErrorMovers for more information.</p> </li> <li> <p>When reconfiguring the project for new hardware, be sure to delete elements of a previous configuration. More info on this is included in the First Steps section.</p> </li> <li> <p>When configuring new hardware, be sure that Is Closed and Is Included in Detection options are set correctly.</p> </li> <li> <p>When programming recovery scenarios, be sure to unregister movers from objectives where necessary.</p> </li> </ul>"},{"location":"GettingStarted/QuickTips.html#general-track-tips","title":"General Track Tips","text":"<p>More generally, here are some recommendations regarding the architecture of your solution:</p> <ul> <li> <p>Proper code should not depend on the number of movers added to the system, and should be easily scalable when movers are added or removed from the system. Directly addressing specific movers by ID should be avoided when possible. See Overview for more information.</p> </li> <li> <p>\"The fleet sails as fast as the slowest ship.\" Overall system throughput is governed by the slowest individual Station's throughput. Focus on understanding the limiting factors of your routing logic in order to optimize traffic flow. A Mover's maximum velocity rarely affects the overall system throughput.</p> </li> </ul>"}]}